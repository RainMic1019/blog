---
title: C语言实现正则表达式匹配
date: 2020-11-22
categories:
 - 程序设计
tags:
 - C
---

## 1 题目描述

传入一个字符串 s 和一个字符规律 p，实现一个支持 '.' 和 '*' 的正则表达式匹配。

 - 字符'.'的含义 ：匹配任意单个字符。
 - 字符'*'的含义： 匹配零个或多个前面的那一个元素。

**注意：匹配是指涵盖整个字符串s，而不是部分字符串。**

**示例1**：

```c
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例2**：

```c
输入：s = "aa" p = "a*"
输出：true
解释：'*' 代表可以匹配零个或多个前面的那个元素, 此处为 'a'，因此，字符串 "aa" 可被视为 'a' 重复一次。
```

**示例3**：

```c
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

**示例3**：

```c
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

## 2 解题思路

1. 如果p为空，s则为空匹配。那么s为空时返回true，s非空时不匹配，直接返回false；
2. 如果p和s都非空，且s和p的第一个字符相同或者p的第一个字符为'.'（\*p == \*s || \*p =='.'）时，匹配第一个字符；
3. 判断p的第二个字符，若\*(p+1) != '\*'，则递归判断剩下的字符是否匹配 first_match && isMatch(++s, ++p)；
4. 若\*(p+1) == '*'，则有两种情况匹配：

```c
a: *匹配0个字符，s匹配剩下的，即isMatch(s, p+2)
b: *匹配1个字符，继续用p匹配剩下的s，即first_match && isMatch(s+1, p)
```

## 3 代码

```c
bool isMatch(char * s, char * p){
    if (!*p) return !*s;
    bool first_match = *s && (*s == *p || *p == '.');
    if (*(p+1) == '*') {
        return isMatch(s, p+2) || (first_match && isMatch(++s, p));
    }
    else {
        return first_match && isMatch(++s, ++p);
    }
}
```

## 4 总结

此处采用了递归的方式暴力破解，该方法的时间复杂度比较高（n^3），如果要降低时间复杂度，可以采用状态机实现，但代码就比较长了。
